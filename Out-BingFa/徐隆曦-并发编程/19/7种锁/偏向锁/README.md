### 
偏向锁/轻量级锁/重量级锁

第一种分类是
偏向锁/轻量级锁/重量级锁，

这三种锁特指 
synchronized 锁的状态，
通过在对象头中的 
mark word 
来表明锁的状态。

偏向锁
如果自始至终，
对于这把锁都不存在竞争，
那么其实就没必要上锁，
只需要打个标记就行了，
这就是偏向锁的思想。
一个对象被初始化后，
还没有任何线程来获取它的锁时，
那么它就是可偏向的，
当有第一个线程
来访问它并尝试获取锁的时候，
它就将这个线程记录下来，
以后如果尝试
获取锁的线程
正是偏向锁的拥有者，
就可以直接获得锁，开销很小，性能最好。

轻量级锁
JVM 开发者发现在很多情况下，
synchronized 中的代码
是被多个线程交替执行的，
而不是同时执行的，
也就是说并不存在实际的竞争，
或者是只有短时间的锁竞争，
用 CAS 就可以解决，
这种情况下，
用完全互斥的重量级锁
是没必要的。
轻量级锁是指当锁
原来是偏向锁的时候，
被另一个线程访问，
说明存在竞争，
那么偏向锁
就会升级为轻量级锁，
线程会通过自旋的形式
尝试获取锁，
而不会陷入阻塞。

重量级锁

重量级锁是互斥锁，
它是利用操作系统的同步机制实现的，
所以开销相对比较大。
当多个线程直接有实际竞争，
且锁竞争时间长的时候，
轻量级锁不能满足需求，
锁就会膨胀为重量级锁。
重量级锁会让其他申请
却拿不到锁的线程
进入阻塞状态。
            
你可以发现锁升级的路径：
无锁→偏向锁→轻量级锁→重量级锁。
 
综上所述，偏向锁性能最好，
可以避免执行 CAS 操作。
而轻量级锁
利用自旋和 CAS 
避免了重量级锁
带来的线程阻塞和唤醒，
性能中等。
重量级锁则会把
获取不到锁的线程阻塞，
性能最差。