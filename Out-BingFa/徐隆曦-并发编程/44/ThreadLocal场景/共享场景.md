### 典型场景2

每个线程内需要保存
类似于全局变量的信息
（例如在拦截器中获取的用户信息），
可以让不同方法直接使用，
避免参数传递的麻烦
却不想被多线程共享
（因为不同线程
获取到的用户信息不一样）。

例如，用 ThreadLocal 
保存一些业务内容
（用户权限信息、
从用户系统获取到的
用户名、用户ID 等），
这些信息
在同一个线程内相同，
但是不同的线程
使用的业务内容
是不相同的。

在线程生命周期内，
都通过这个
静态 ThreadLocal 实例
的 get() 方法
取得自己 set 过的那个对象，
避免了将这个对象
（如 user 对象）
作为参数传递的麻烦。

我们用图画的形式
举一个实例：

比如说我们是一个用户系统。
假设不使用 ThreadLocal，
那么当一个请求进来的时候，
一个线程会负责执行这个请求，
然后这个请求就会依次调用
service-1()、service-2()、
service-3()、service-4()，
这 4 个方法
可能是分布在不同的类中的。

在 service-1() 的时候它会创建一个 user 的对象，
用于保存比如说这个用户的用户名等信息，
后面 service-2/3/4() 
都需要用到这个对象的信息，
比如说 
service-2() 代表下订单、
service-3() 代表发货、
service-4() 代表完结订单，
在这种情况下，每一个方法都需要用户信息，
所以就需要把这个 user 对象层层传递下去，
从 service-1() 传到 service-2()，
再从 service-2() 传到 service-3()，
以此类推。

这样做会导致代码非常冗余，
那有没有什么办法可以解决这个问题呢？
我们首先想到的方法就是
使用一个 HashMap，
如下图所示：


比如说我们使用了这样的 Map 之后，
就不需要把 user 对象层层传递了，
而是在执行 service-1() 的时候，
把这个用户信息给 put 进去，
然后后面需要拿用户信息的时候，
直接从静态的 User map 里面 get 就可以了。
这样一来，无论你执行哪个方法，
都可以直接获取到这个用户信息。
当然，我们也要考虑到 web 服务器
通常都是多线程的，
当多个线程同时工作的时候，
我们也需要保证线程安全。

所以在这里，如果我们使用 HashMap 是不够的，
因为它是线程不安全的，
那我们就可以使用 synchronized，
或者直接把 HashMap 替换成 ConcurrentHashMap，
用类似的方法来保证线程安全，
这样的改进如下图所示：

在这个图中，可以看出有两个线程，
并且每个线程所做的事情都是访问 service-1/2/3/4()。
那么当它们同时运行的时候，
都会同时访问这个 User map，
于是就需要 User map 是线程安全的。

无论我们使用 synchronized 还是使用 ConcurrentHashMap，
它对性能都是有所影响的，
因为即便是使用
性能比较好的 ConcurrentHashMap，
它也是包含少量的同步，
或者是 cas 等过程。
相比于完全没有同步，
它依然是有性能损耗的。
所以在此一个更好的办法
就是使用 ThreadLocal。

这样一来，我们就可以在不影响性能的情况下，
也无需层层传递参数，
就可以达到
保存当前线程所对应的用户信息的目的。
如下图所示：

在这个图中可以看出，
同样是多个线程同时去执行，
但是这些线程同时去访问这个 ThreadLocal 
并且能利用 ThreadLocal 
拿到只属于自己的独享对象。
这样的话，就无需任何额外的措施，
保证了线程安全，
因为每个线程是独享 user 对象的。
代码如下所示：


```
public class ThreadLocalDemo07 {

    public static void main(String[] args) {
        new Service1().service1();

    }
}

class Service1 {

    public void service1() {
        User user = new User("拉勾教育");
        UserContextHolder.holder.set(user);
        new Service2().service2();
    }
}

class Service2 {

    public void service2() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service2拿到用户名：" + user.name);
        new Service3().service3();
    }
}

class Service3 {

    public void service3() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service3拿到用户名：" + user.name);
        UserContextHolder.holder.remove();
    }
}

class UserContextHolder {

    public static ThreadLocal<User> holder = new ThreadLocal<>();
}

class User {

    String name;

    public User(String name) {
        this.name = n
    }
}
```

在这个代码中我们可以看出，
我们有一个 UserContextHolder，
里面保存了一个 ThreadLocal，
在调用 Service1 的方法的时候，
就往里面存入了 user 对象，
而在后面去调用的时候，
直接从里面
用 get 方法
取出来就可以了。
没有参数层层传递的过程，
非常的优雅、方便。

代码运行结果：

复制
Service2拿到用户名：拉勾教育
Service3拿到用户名：拉勾教育